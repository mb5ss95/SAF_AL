#include <iostream>
using namespace std;

// 테트로미노

// 시간복잡도 
// 1. Backtracking 
// 2. DFS (거리 4짜리 DFS) 
// --> 모든 점을 접근해보는 시간 = O(N^2) = 500 x 500 = 250,000
// --> 모든 점에서 거리 4짜리 DFS (4^4 --> 아주 대충) = 600 (nPr) 
// 3. Tshape --> O(1)

/*
5 5
1 2 3 4 5
5 4 3 2 1
2 3 4 5 6
6 5 4 3 2
1 2 1 2 1
*/

/*
4 5
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
*/

int n, m; // n : 세로크기,  m : 가로크기 
int MAP[500][500]; // MAP 최대크기 = 500
int visited[500][500];
int sum = 0; // 누적합
int cnt = 0;
int ans = -2134567890;

int ydir[] = { 0, 0, 1, -1 };
int xdir[] = { 1, -1, 0, 0 };

// T방향배열
// 0 : ㅗ
// 1 : ㅏ 
// 2 : ㅓ
// 3 : ㅜ
int tydir[4][4] = {
	{0, 0, -1, 0},
	{0, 1, 1, 2},
	{0, -1, 0, 1},
	{0, 0, 0, 1}
};
int txdir[4][4] = {
	{0, 1, 1, 2},
	{0, 0, 1, 0},
	{0, 1, 1, 1},
	{0, 1, 2, 1}
};

// (y,x)위치에서 T자 모양 4개를 다 만들어볼 함수
void tshape(int y, int x) {
	// T로는 4개의 모양을 만들어볼수 있죠 
	for (int i = 0; i < 4; i++) {
		int s = 0;
		// 각 모양에 대해 4개에 대한 방향배열로 값을 구해봄 
		for (int j = 0; j < 4; j++) {
			int ny = y + tydir[i][j];
			int nx = x + txdir[i][j];
			// 방향배열 썼으니까 -> 범위체크 
			// 만약 여기서는 범위가 벗어나면 -> 이 모양은 만들 수 없다!
			// 다음 모양을 만들어보기 시작 
			if (ny < 0 || nx < 0 || ny >= n || nx >= m)
				break;
			// 이 부분까지의 합은 구해야함 
			s += MAP[ny][nx];
		}
		// ---- break 를 안만났다 -> 해당 모양을 만들수 있었다!
		// T자 모양에 대한 정답 갱신을 해봅니다 
		if (s > ans)
			ans = s;
	}
}


void dfs(int y, int x) {
	// **옵션 기저조건 
	// --> 4개의 연결된 테트로미노를 만들었다면 --> 더 가볼필요 없다!
	if (cnt == 4) {
		// 지금 여기까지 왔을때의 누적합이 최대값이면 -> 갱신 
		if (sum > ans)
			ans = sum;

		// 돌아가라!
		return;
	}

	// 재귀 구성
	// 상하좌우 방향으로 뻗어나가볼것. 
	for (int i = 0; i < 4; i++) {
		int ny = y + ydir[i];
		int nx = x + xdir[i];
		// 방향배열을 사용할때에는 최우선순위 체크 -> 범위체크
		if (ny < 0 || nx < 0 || ny >= n || nx >= m)
			continue;
		// 다음 위치 이미 방문했다면 -> continue
		if (visited[ny][nx] == 1)
			continue;

		// ------여기까지 왔다-------
		// 다음 연결될 블록을 찾았다1 
		// 여기서 계속 또 들어가봐야 함 
		// 이 점을 기준으로 탐색 시작! 
			// 1. 갔던곳 다시 돌아가보지 않도록 ->  방문 기록 
		visited[ny][nx] = 1;
		// 2. 합 처리
		sum += MAP[ny][nx];
		// 3. 몇개의 블록을 봤는가? 
		cnt++;

		dfs(ny, nx);

		// *BACKTRACKING 구성
		// (i, j)위치에서 모든 4칸짜리를 탐색하고 나면 -> 다음 칸으로 이동 
		// 지금 여기에서 기록했던거 싹~다 초기화 
		// 1. 방문 해제
		visited[ny][nx] = 0;
		// 2. 합 차감
		sum -= MAP[ny][nx];
		// 3. 블록 사용 차감
		cnt--;
	}
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	// input 
	cin >> n >> m;
	for (int i = 0; i < n; i++)
		for (int j = 0; j < m; j++)
			cin >> MAP[i][j];

	// 모든 칸에서 한번씩
	// 1. 거리 4개짜리 DFS를 돌려보면서 누적합을 구하고, 최대값 갱신 
	// 2. T모양은 따로 방향배열 만들어서 처리를 해줄거예요 .
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			// 이 점을 기준으로 탐색 시작! 
			// 1. 갔던곳 다시 돌아가보지 않도록 ->  방문 기록 
			visited[i][j] = 1;
			// 2. 합 처리
			sum += MAP[i][j];
			// 3. 몇개의 블록을 봤는가? 
			cnt++;

			dfs(i, j);

			// *BACKTRACKING 구성
			// (i, j)위치에서 모든 4칸짜리를 탐색하고 나면 -> 다음 칸으로 이동 
			// 지금 여기에서 기록했던거 싹~다 초기화 
			// 1. 방문 해제
			visited[i][j] = 0;
			// 2. 합 차감
			sum -= MAP[i][j];
			// 3. 블록 사용 차감
			cnt--;

			//---------------------------------------------
			// T자를 제외한 모든 도형 상태의 누적합을 구했음. (i,j 위치 시작했을때)
			// T자 처리
			tshape(i, j);

		}
	}
	cout << ans;
}